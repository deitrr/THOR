* Tools to debug your code
Thor contains some tools to check values and get some feedback when everything fails.
** Binary comparison
   To test consistency when making code changes that shouldn't impact computation, there is a tool in place to check that the results are the same.
   The idea is to run the code without the changes and dump tables of the state of the simulation at various points through the update loop.
   Then, we can integrate the changes, and run the code again, but this time, reading the tables we dumped before, and comparing the values, to check that we still obtain the same values. 
   It will report the errors if finds, with some pointers to what table changed and at what point of the simulation. This helps to find out at what step the results startto change and can help to pinpoint what changes impacted the bahaviour.

** NaN Checks
   The code can run NaN checks on various tables, to test that the simulation values didn't explode and go crazy.
** CUDA check
   Checks and reports the last CUDA error
** How to enable the tests
   The main point to enable the tests are the ~#defines~ in ~src/headers/debug.h~. The tests are enabled by uncommenting some of the defines and recompiling.

   - ~BENCHMARKING~ main switch to enable or disable benchmarking, without this enabled, no other benchmarking code is activated.
   - ~BENCH_POINT_WRITE~ enables writing of reference files to ~results/ref/~.
   - ~BENCH_POINT_COMPARE~ enable comparison of simulation data to reference files saved previously with ~BENCH_POINT_WRITE~.
   - ~BENCH_PRINT_DEBUG~ by default, only print out if comparison failed, with this enabled, print state of comparison at each step.
   - ~BENCH_NAN_CHECKS~ enables NaN checks on data table.
   - ~BENCH_CHECK_LAST_CUDA_ERROR~ enables check of the last cuda error and report if there is one.
*** what gets checked?
    The code contains lines like this
#+BEGIN_SRC C++
    BENCH_POINT_I_S( current_step, rk, "RK2", vector<string>({}), vector<string>({"Rho_d", "pressure_d", "Mh_d", "Wh_d", "temperature_d", "W_d"}))
#+END_SRC
   Those are test points enabled with the ~#define~ flags described above. 
   - 1, 2 or 3 arguments (depending on using ~BENCH_POINT_I~, ~BENCH_POINT_I_S~, ~BENCH_POINT_I_SS~ describing the level in the update loop. (first iteration, sub-iteration and sub-sub-iteration)
   - String argument describing the step in update loop. (e.g. "RK2": second Runge Kutta step, "Vertical_Eq": vertical equilibrium computation.)
   - vector of string describing the arguments that are inputs to next step of simulation (currently unused, but can get stored to make comparisons between input and outputs)
   - vector of string describing the arguments that are outputs of the previous step of the simulation (before the call to the debug function)

The vector of strings describe tables that need to be analysed. Their description is stored in a table, built in ~src/devel/binary_test.cpp:build_definitions( ESP & esp, Icogrid & grid)~ function. This describes tables of doubles:

#+BEGIN_SRC C++
// {named index, { pointer, size, long name, short name, on device }}
 {"Rho_d",         { esp.Rho_d,         esp.nv*esp.point_num,   "Density", "rho", true}},
#+END_SRC

  - named index: the index used in the code to find the info for that element
  - pointer: the pointer to the data (on device or host)
  - size: the size of the table
  - name: the name to display 
  - short name: the name to use in short debug summary
  - on device: boolean telling if the pointer points to data on device or on host. If the data is on the device, it will copy the data to host or work on it on the device if needed.

    If you want to check other tables, add them to the list through their pointer in the ESP object and add their named index to the ~BENCH_POINT_I...()~ calls wher you want to check them.
** How to add more tests
   To add other debug tools, you can add them in the function  ~src/devel/binary_test.cpp::check_data(...)~, with an appropriate ~#ifdef~ clause. 
   The function gets some text for the iteration count and the name of the steps, and a vector of tables to work on. It computes the definitions of tables (with pointers and sizes) to work on at the top.
